#!/usr/bin/env python

import os, sys, pwd, getopt, datetime, time, cgi, urlparse, signal, string
from time import sleep
import MySQLdb as db
import json
from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
from SocketServer import ThreadingMixIn
import threading, mimetypes, ssl, hashlib
from struct import pack, unpack, unpack_from

#add bitcoin.conf: blocknotify="curl -s --connect-timeout 1 http://localhost:8085/notify -d %s -d pwd=testing"

version = "0.1.0"
cfg = { 'log':sys.argv[0]+'.log', 'listen':'localhost:8085', 'www':'www', 'db':'localhost:btc:test623btc:bitcoin', 'block':0, 'pwd':'testing' }

class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    """ This class allows to handle requests in separated threads.
        No further content needed, don't touch this. """
        
class WebHandler(BaseHTTPRequestHandler):
    server_version = 'sqlChain/1.0'
    def do_GET(self):
        global wsts
        try:
            q = urlparse.urlparse(self.path)
            g =  urlparse.parse_qs(q.query)
            path = '/main.html' if q.path == '/' else q.path
            if os.path.isfile(cfg['www']+path):
                _,ext = os.path.splitext(path)
                filesize = os.path.getsize(cfg['www']+path)
                f = open(cfg['www']+path) 
                self.send_response(200)
                self.send_header('Content-type', mimetypes.types_map[ext])
                self.send_header('Content-Length', filesize)
                self.send_header('Expires', self.date_time_string(time.time()+3600))
                self.end_headers()
                self.wfile.write(f.read())
                f.close()
                return
            if path.startswith("/api"):
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                sql = db.connect(*cfg['db'].split(':'))
                data = self.do_API(path[4:], sql.cursor())
                self.wfile.write(json.dumps(data))
                return
                                
        except IOError:
            pass
        self.send_error(404,'File Not Found: %s' % self.path)

    def do_POST(self):
        form = cgi.FieldStorage(fp=self.rfile, headers=self.headers, keep_blank_values=True, environ={'REQUEST_METHOD':'POST','CONTENT_TYPE':self.headers['Content-Type']})
        self.send_response(200)
        self.send_header('Content-type','text/html')
        self.end_headers()
        if self.path.endswith("/notify") and form['pwd'].value == cfg['pwd']:
            cfg['block'] = int(form['block'].value)
            savecfg()
        return
                
    def do_API(self, path, cur):
        if path.startswith("/block-index/"):
            blk = path[13:]
            if blk.isdigit():
                cur.execute("select hash from blocks where id=%s*4 limit 1;", (blk,))
                row = cur.fetchone()
                if row:
                    return { 'blockHash': row[0][::-1].encode('hex') }
        if path.startswith("/block/"):
            blkhash = path[7:]
            if len(blkhash) == 64 and all(c in string.hexdigits for c in blkhash):
                data = { 'hash':blkhash, 'tx':[] }
                cur.execute("select id,hash,hdr from blocks where hash=%s limit 1;", (blkhash.decode('hex')[::-1],))
                row = cur.fetchone()
                if row:
                    data['height'] = int(int(row[0])/4)
                    data['confirmations'] = cfg['block'] - data['height']
                    data.update(gethdr(row[2]))
                    data['previousblockhash'] = data['previousblockhash'][::-1].encode('hex')
                    data['merkleroot'] = data['merkleroot'][::-1].encode('hex')
                    data['difficulty'] = bits2diff(data['bits'])
                    data['bits'] = '%08x' % data['bits']
                    data['reward'] = float((50 * 100000000) >> (data['height'] / 210000))/1e8
                    data['isMainChain'] = True
                    cur.execute("select hash from trxs where block_id=%s;", (row[0],))
                    for tx in cur:
                        data['tx'].append(tx[0][:32][::-1].encode('hex'))
                    cur.execute("select hash from blocks where id=%s*4 limit 1;", (data['height']+1,))
                    row = cur.fetchone()
                    if row:
                        data['nextblockhash'] = row[0][::-1].encode('hex')
                return data
        if path.startswith("/tx/"):
            txhash = path[4:]
            if len(txhash) == 64 and all(c in string.hexdigits for c in txhash):
                data = { 'txid':txhash }
                th = txhash.decode('hex')[::-1]
                tid = unpack('<q', th[:5]+'\0'*3)[0] >> 4
                cur.execute("select id,hash,txdata,block_id from trxs where id>=%s and left(hash,32)=%s limit 1;", (tid,th))
                row = cur.fetchone()
                if row:
                    data['confirmations'] = cfg['block'] - row[3]/4
                    data['version'],data['locktime'] = unpack_from('<BI', row[1], 32)
                    data['valueIn'],data['vin'] = mkInputs(cur, int(row[2]))
                    data['valueOut'],data['vout'] = mkOutputs(cur, int(row[0]))
                    data['fees'] = data['valueIn'] - data['valueOut']
                    cur.execute("select hash,hdr from blocks where id=%s limit 1;", (row[3],))
                    row = cur.fetchone()
                    if row:
                        data['blockhash'] = row[0][::-1].encode('hex')
                        data['time'] = data['blocktime'] = gethdr(row[1])['time']
                    return data
            
        return { 'error': 'no result' }
        
    def log_message(self, format, *args):
        if cfg['debug']:
            logts( format % args )
        pass
        
# cfg file and option handling stuff

def loadcfg():
    global cfg
    try:
        with open(sys.argv[0]+'.cfg') as json_file:
            cfg = json.load(json_file)
    except IOError:
        logts('No cfg file.')
    finally:
        cfg['debug'] = False
        options()

def savecfg():
    try:
        with open(sys.argv[-1] if sys.argv[-1][0] != '-' else sys.argv[0]+'.cfg', 'w') as json_file:
            json.dump(cfg, json_file, indent=2)
    except IOError:
        logts('Cannot save cfg file')

def options():
    global cfgfile
    try:                                
        opts,args = getopt.getopt(sys.argv[1:], "hvb:p:c:d:l:s:a:w:r:u:", 
            ["help", "version", "debug", "db=", "log=", "listen=", "www=", "user=", "defaults" ])
    except getopt.GetoptError:
        usage()
    for opt,arg in opts:
        if opt in ("-h", "--help"):
            usage()
        elif opt in ("-v", "--version"):
            sys.exit('Version: '+version)
        elif opt in ("-d", "--db"):
            cfg['db'] = arg
        elif opt in ("-l", "--log"):
            cfg['log'] = arg
        elif opt in ("-w", "--www"):
            cfg['www'] = arg            
        elif opt in ("-a", "--listen"):
            cfg['listen'] = arg
        elif opt in ("--defaults"):
            savecfg()
            print "%s updated" % (sys.argv[0]+'.cfg')
            sys.exit()
        elif opt in ("--debug"):
            cfg['debug'] = True
            
def usage():
    print """Usage: %s [options...][cfg file]\nCommand options are:\n-h,--help\tShow this help info\n-v,--version
\tShow version info\n--defaults\tUpdate cfg and exit\nDefault files are %s.cfg .log .db
\nThese options get saved in cfg file as default.
-l,--listen\tSet host:port for web server\n-w,--www\t\tWeb server root directory\n-u,--user\tSet user to run as
-d,--db  \tSet mysql db and login\n-l,--log\tSet log file path""" % (sys.argv[0], sys.argv[0])
    sys.exit(2) 
                        
def logts(msg):
    print datetime.datetime.now().strftime('%d-%m-%Y %H:%M:%S'), msg
    sys.stdout.flush()  
    
b58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

def is_address(addr):
    try:
        n = 0
        for c in addr:
            n = n * 58 + b58.index(c)
        btc = ('%%0%dx' % (25 << 1) % n).decode('hex')[-25:]
        return btc[-4:] == sha256(sha256(btc[:-4]).digest()).digest()[:4]
    except Exception:
        return False
        
def mkaddr(pkh, ver=0):
    pad = ''
    an = chr(ver) + str(pkh)
    for c in an:
        if c == '\0': pad += '1'
        else: break
    num = long((an + hashlib.sha256(hashlib.sha256(an).digest()).digest()[0:4]).encode('hex'), 16)
    out = ''
    while num >= 58:
        num,m = divmod(num, 58)
        out = b58[m] + out
    return pad + b58[num] + out            
            
def bits2diff(bits):
    return (0x00ffff * 2**(8*(0x1d - 3)) / float((bits&0xFFFFFF) * 2**(8*((bits>>24) - 3))))
def gethdr(data):
    return dict(zip(['version','previousblockhash','merkleroot', 'time', 'bits', 'nonce'], unpack_from('<I32s32s3I', data)))
    
    
def mkInputs(cur, blob):
    total = 0
    data = []
    ins,outs = unpack('<HH', readBlob(blob, 4))
    inputs = unpack('<'+'Q'*ins, readBlob(blob+4, ins*8))
    for n,in_id in enumerate(inputs):
        cur.execute("select value,addr,left(hash,32) from outputs o, address a, trxs t where o.id=%s and a.id=o.addr_id and t.id=%s limit 1;", (in_id,in_id/4096))
        row = cur.fetchone()
        if row:
            btc = float(row[0])/1e8
            data.append({ 'n':n, 'vout':in_id%4096, 'value':btc, 'valueSat':int(row[0]), 'txid':row[2][::-1].encode('hex'), 'addr':mkaddr(row[1]) })
            total += btc
    return total,data
    
def mkOutputs(cur, txid):
    total = 0
    data = []
    cur.execute("select o.id%%4096,value,addr,o.tx_id,o.id from outputs o, address a where o.id>=%s*4096 and o.id<%s*4096 and a.id=o.addr_id;", (txid,txid+1))
    outs = cur.fetchall()
    for out in outs:
        btc = float(out[1])/1e8
        vo = { 'n':int(out[0]), 'value':"%1.8f" % btc }
        vo['scriptPubKey'] = { 'addresses':[ mkaddr(out[2]) ] }
        if out[3]:
            vo.update(mkSpent(cur, int(out[3]), int(out[4])))
        total += btc
        data.append(vo)
    return total,data
    
def mkSpent(cur, txid, outid):
    cur.execute("select txdata,left(t.hash,32),hdr from trxs t, blocks b where t.id=%s and b.id=t.block_id;", (txid,))
    row = cur.fetchone()
    if row:
        ins,outs = unpack('<HH', readBlob(int(row[0]), 4))
        inputs = unpack('<'+'Q'*ins, readBlob(int(row[0])+4, ins*8))
        return { 'spentTxId':row[1][::-1].encode('hex'), 'spentIndex':inputs.index(outid), 'spentTs':gethdr(row[2])['time'] }
    return {}

def readBlob(pos, sz):
    if sz != 0:
        with open('/var/data/blobs.dat', 'rb') as blob:
            blob.seek(pos)
            return blob.read(sz)
    return None
        
def sigterm_handler(_signo, _stack_frame):
    logts("Shutting down.")
    sys.exit(0)
    
def drop2user():
    global drop
    if ('user' in cfg) and (cfg['user'] != '') and (os.getuid() == 0):
        drop.wait()
        uid = pwd.getpwnam(cfg['user']).pw_uid
        os.setgroups([])
        os.setgid(uid)
        os.setuid(uid)
        os.umask(077)      
    
if __name__ == '__main__':
    
    loadcfg()
        
    if not cfg['debug']:
        sys.stdout = open(cfg['log'], 'a')
        signal.signal(signal.SIGTERM, sigterm_handler)
    
    mimetypes.init()
    mimetypes.add_type('application/x-font-woff', '.woff')
    mimetypes.add_type('application/x-font-woff2', '.woff2')
    mimetypes.add_type('application/x-font-woff', '.ttf')
    
    host,port = cfg['listen'].split(':')
    server = ThreadedHTTPServer((host, int(port)), WebHandler)
    if ('ssl' in cfg) and (cfg['ssl'] != ''):
        server.socket = ssl.wrap_socket (server.socket, certfile=cfg['ssl'], server_side=True)
    drop2user()
    
    logts("Starting on %s" % cfg['listen'])
    try:
        server.serve_forever()
        
    except KeyboardInterrupt:
        sys.exit(0)

        
