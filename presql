#!/usr/bin/env python
#
# sqlcoin - build sql blockchain db
#

import os, sys, socket, datetime, time
import select, termios, fcntl
from bitcoinrpc.authproxy import AuthServiceProxy
from decimal import *
from struct import pack, unpack, unpack_from
import json, hashlib

state = { 'pause':False }

alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

def mkpkh(pk):
    rmd = hashlib.new('ripemd160')
    rmd.update(hashlib.sha256(pk).digest())
    return rmd.digest()

def addr2pkh(v):
    long_value = 0L
    for (i, c) in enumerate(v[::-1]):
        long_value += alphabet.find(c) * (58**i)
    result = ''
    while long_value >= 256:
        div, mod = divmod(long_value, 256)
        result = chr(mod) + result
        long_value = div
    result = chr(long_value) + result
    nPad = 0
    for c in v:
        if c == alphabet[0]: nPad += 1
        else: break
    result = chr(0)*nPad + result
    return result[1:-4]

def mkaddr(pkh):
    pad = ''
    an = chr(0) + str(pkh)
    for c in an:
        if c == '\0': pad += '1'
        else: break
    num = long((an + hashlib.sha256(hashlib.sha256(an).digest()).digest()[0:4]).encode('hex'), 16)
    out = ''
    while num >= 58:
        num,m = divmod(num, 58)
        out = alphabet[m] + out
    return pad + alphabet[num] + out    
   
def IsKbdCmd(db):
    while True:
        if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:
            key = sys.stdin.read(1)
            if key == 'x':
                return False
            elif key == ' ':
                state['pause'] = not state['pause']
                if state['pause']:
                    print "\n--- press space to resume ---"
            elif key == 's':
                pass
            
        if not state['pause']:
            return True
        time.sleep(0.5)

def processBlocks():
    rpc = AuthServiceProxy("http://chris:cZ9k7ca22UIwPobTGQUm@cubian:8332")
    db = { 'address': { 'fd':None, 'page':3, 'size':6+16, 'pgbits':15 },
           'trxs': { 'fd':None, 'page':4, 'size':6+6+6+4, 'pgbits':12 },
           'outputs': { 'fd':None, 'page':8, 'size':6+8+6, 'pgbits':24 },
           'scripts': { 'fd':None, 'page':6, 'size':6+6+6, 'pgbits':24 },
           'blocks': { 'fd':None, 'size':4+32+6 } }
              
    for f in db:
        db[f]['fd'] = open('data/'+f+'.dat', 'r+b')
    
    blk = 0
    db['blocks']['fd'].seek(0,2)
    if db['blocks']['fd'].tell() > 0:
        db['blocks']['fd'].seek( -(db['blocks']['size']), 2)
        chk = db['blocks']['fd'].read(db['blocks']['size'])
        blk, = unpack('<I', chk[:4])
        blk = blk/4 + 1
    startblk = blk
    
    while IsKbdCmd(db):
        blkhash = rpc.getblockhash(blk)
        if blkhash:
            data = decodeBlock(rpc.getblock(blkhash, False).decode('hex'))
            if data: 
                data['height'] = int(blk)
                insertBlock(db, data)
                blk += 1
            else: break
            
    for f in db:
        db[f]['fd'].flush()
        os.fsync(db[f]['fd'].fileno())
        db[f]['fd'].close()
        
    return blk - startblk

def decodeBlock(data):
    hdr = ['version','previousblockhash','merkleroot', 'time', 'bits', 'nonce']
    hv = unpack_from('<I32s32s3I', data)
    block = dict(zip(hdr,hv))
    block['hdr'] = data[:80]
    block['hash'] = hashlib.sha256(hashlib.sha256(block['hdr']).digest()).digest()
    block['bits'] = '%08x' % block['bits'] 
    txcnt,off = decodeVarInt(data[80:89])
    off += 80
    block['tx'] = []
    while txcnt > 0:
        tx,toff = decodeTx(data[off:])
        block['tx'].append(tx)
        off += toff
        txcnt -= 1
    block['height'] = 0
    if block['version'] > 1:
        block['height'] = unpack('<I', block['tx'][0]['vin'][0]['coinbase'][1:4]+'\0')[0]
    return block
    
def decodeTx(data):
    vers, = unpack_from('<I', data)
    tx = { 'version': vers, 'vin':[], 'vout':[] }
    vicnt,off = decodeVarInt(data[4:13])
    off += 4
    while vicnt > 0:
        txid,vout = unpack_from('<32sI', data, off)
        sigsz,soff = decodeVarInt(data[off+36:off+36+9])
        off += soff+36
        seq, = unpack_from('<I', data, off+sigsz)
        if txid == '\0'*32 and vout == 0xffffffff: 
            tx['vin'].append({'coinbase':data[off:off+sigsz], 'sequence':seq })
        else:
            tx['vin'].append({'txid':txid, 'vout':vout, 'scriptSig':data[off:off+sigsz], 'sequence':seq })
        off += sigsz+4
        vicnt -= 1
    vocnt,voff = decodeVarInt(data[off:off+9])
    off += voff
    n = 0
    while n < vocnt:
        value, = unpack_from('<Q', data, off)
        pksz,soff = decodeVarInt(data[off+8:off+8+9])
        off += 8+soff
        tx['vout'].append({'value':value, 'n':n, 'scriptPubKey':decodeScriptPK( data[off:off+pksz] ) }) 
        off += pksz
        n += 1
    tx['locktime'], = unpack_from('<I', data, off)
    tx['txid'] = hashlib.sha256(hashlib.sha256(data[:off+4]).digest()).digest()
    return tx,off+4

def decodeScriptPK(data):
    if data[:3] == '\x76\xa9\x14' and data[23:25] == '\x88\xac': # P2PKH
        return { 'type':'p2pkh', 'data':'', 'addr':mkaddr(data[3:23]) };
    if data[0] == '\xa9' and data[21] == '\x87': # P2SH
        return { 'type':'p2sh', 'data':'', 'addr':data[1:21] };
    if data[0] == '\x41' and data[66] == '\xac': # P2PK
        return { 'type':'p2pk', 'data':data, 'addr':mkaddr(mkpkh(data[1:66])) };
    if len(data) <= 41 and data[0] == '\x6a': # NULL
        return { 'type':'null', 'data':data };
    return { 'type':'other', 'data':data } # other, non-std

def decodeVarInt(v):
    if v[0] <= '\xfc':
        return unpack('<B', v[0])[0],1
    if v[0] == '\xfd':
        return unpack('<H', v[1:3])[0],3
    if v[0] == '\xfe':
        return unpack('<I', v[1:5])[0],5
    return unpack('<Q', v[1:9])[0],9
    
def insertAddress(db, addr):
    #print 'inserting addr', addr
    pkh = addr2pkh(addr)
    addr_id, = unpack('<q', pkh[:5]+'\0'*3) 
    addr_id *= 2
    if addr[0] == '3': # encode P2SH as odd id, P2PKH as even id
        addr_id += 1
    while not insertSpace(db, addr_id, 1, True):
        addr_id += 2
    db['fd'].write( pack('<Q', addr_id)[:6] + pkh[:16] )
    return addr_id
    
def insertTx(db, blk_id, txhash, inputs, extra): 
    #print 'inserting tx', txhash.encode('hex')
    tx_id, = unpack('<q', txhash[:5]+'\0'*3)
    tx_id /= 16
    while not insertSpace(db, tx_id, 1, True):
        tx_id += 1
    ids = pack('<3Q', tx_id, insertBlob(txhash+extra), insertBlob(inputs))
    db['fd'].write( ids[:6] + ids[8:14] + ids[16:22] + pack('<I', blk_id) )
    return tx_id
    
def findTx(db, txhash, limit=32):  
    tx_id, = unpack('<q', txhash[:5]+'\0'*3) 
    tx_id /= 16
    limit_id = tx_id+limit
    db['fd'].seek( (tx_id>>db['pgbits']) * db['size'] * db['page'] )
    while True:
        chk = db['fd'].read(db['size'])
        cid,blob = unpack('<QQ', chk[:6]+'\0\0'+chk[6:12]+'\0\0')
        if cid == 0:
            return None
        if cid == tx_id:
            if txhash == getBlob(blob, 32):
                return tx_id
            tx_id += 1
        if tx_id > limit_id:
            return None
        
def insertOutputs(db, outs):
    insertSpace(db, outs[0][0], len(outs))
    for out_id,addr_id,value in outs:
        ids = pack('<QQ', out_id, addr_id)
        db['fd'].write( ids[:6] + pack('<Q', value) + ids[8:14] )
            
def insertScripts(db, pks, sigs):
    insertSpace(db, pks[0][0], len(pks))
    for out_id,blob in pks:
        ids = pack('<QQ', out_id, blob)
        db['fd'].write( ids[:6] + ids[8:14] + '\0'*6 )
    for out_id,sig in sigs:
        db['fd'].seek( (out_id>>24) * db['size'] * db['page'] )
        while True:
            chk = db['fd'].read(db['size'])
            cid, = unpack('<Q', chk[:6]+'\0\0')
            if cid == 0:
                print 'sig insert error - no out_id', out_id
                break
            if cid == out_id:
                db['fd'].seek(-6,1)
                db['fd'].write( pack('<Q', sig)[:6] )
                break
   
def insertBlob(data):
    if len(data) == 0:
        return 0
    with open('data/blobs.dat', 'r+b') as blob:
        blob.seek(0,2)
        pos = blob.tell()
        blob.write(data)
    return pos
    
def getBlob(pos, size):
    with open('data/blobs.dat', 'rb') as blob:
        blob.seek(pos)
        data = blob.read(size)
    return data

def insertSpace(db, rid, rows, bUnique=False):
    n = 0
    buf = []
    db['fd'].seek( (rid>>db['pgbits']) * db['size'] * db['page'] )
    while True:
        inspos = db['fd'].tell()
        chk = db['fd'].read(db['size'])
        if chk == '':
            return True
        cid, = unpack('<Q', chk[:6]+'\0\0')
        #print 'locating', cid, rid
        if cid == 0:
            n = 1
            break
        elif cid > rid:
            buf.append(chk)
            break
        elif cid == rid and bUnique: 
            return False
        
    while n < rows:
        chk = db['fd'].read(db['size'])
        if chk == '':
            db['fd'].seek((rows-n)*db['size'], 1)
            break
        cid, = unpack('<Q', chk[:6]+'\0\0')
        if cid == 0:
            n += 1
        else:
            buf.append(chk)
    
    db['fd'].seek( -len(buf) * db['size'], 1)
    for row in buf:
        db['fd'].write(row)
    db['fd'].seek( inspos )
    return True

def insertBlock(db, data):
    print "block", data['height'],
    blkstart = time.time()
    blk_id = data['height']*4
    rcnt = 0
    for tx in data['tx']:
        inputs = ''
        sigs = []
        for vin in tx['vin']:
            if 'coinbase' in vin:
                data['coinbase'] = vin['coinbase']
            if 'txid' in vin:
                tx_id = findTx(db['trxs'], vin['txid'])
                in_id = (tx_id << 12) + vin['vout']
                inputs += pack('<Q', in_id)
                sig = vin['scriptSig'] + pack('<I', vin['sequence'])
                sigs.append( (in_id, insertBlob(sig)) )
                rcnt += 1
                
        tx_id = insertTx(db['trxs'], blk_id, tx['txid'], inputs, pack('<BI', tx['version'], tx['locktime']))
        rcnt += 1
        pks = []
        outs = []
        for vout in tx['vout']:
            out_id = (tx_id << 12) + vout['n']
            addr_id = insertAddress(db['address'], vout['scriptPubKey']['addr']) if 'addr' in vout['scriptPubKey'] else 0
            pks.append( (out_id, insertBlob(vout['scriptPubKey']['data'])) )
            outs.append( ( out_id, addr_id, vout['value'] ) )
            rcnt += 2
        insertOutputs(db['outputs'], outs)
        insertScripts(db['scripts'], pks, sigs)
        rcnt += 1
            
    db['blocks']['fd'].write( pack('<I32sQ', blk_id, data['hash'], insertBlob(data['hdr']+data['coinbase']))[:db['blocks']['size']] )
    rcnt += 1
    blktime = time.time() - blkstart
    print "[ %3d txs - %s - %4d r/s ]" % (len(data['tx']), datetime.datetime.fromtimestamp(data['time']).strftime('%d-%m-%Y'), int(rcnt/blktime))

    
if __name__ == '__main__':

    # set console for non-blocking key input
    fd = sys.stdin.fileno()
    oldterm = termios.tcgetattr(fd)
    newattr = termios.tcgetattr(fd)
    newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO
    termios.tcsetattr(fd, termios.TCSANOW, newattr)
    
    oldflags = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, oldflags | os.O_NONBLOCK)

    workstart = time.time()
    try:
        blks = processBlocks()
    except socket.error:
        print "Cannot connect to rpc"
    except KeyboardInterrupt:
        pass
    finally:
        # restore console
        termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm)
        fcntl.fcntl(fd, fcntl.F_SETFL, oldflags)
    
    print "Session %.1f blks/s" % float(blks / (time.time() - workstart))


    

