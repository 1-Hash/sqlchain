#!/usr/bin/env python
#
#   sqlchaind - daemon to update sql blockchain db
#
import os, sys, socket, time, threading
import select, termios, fcntl
import MySQLdb as db

from datetime import datetime
from bitcoinrpc.authproxy import AuthServiceProxy
from struct import pack, unpack, unpack_from
from hashlib import sha256
from sqlchainlib import *

cfg = { 'log':sys.argv[0]+'.log', 'db':'localhost:btc:test623btc:bitcoin', 'rpc':'http://chris:cZ9k7ca22UIwPobTGQUm@cubian:8332' } 

state = { 'pause':False }

blockQ = []
memPool = set()
done = threading.Event()
   
def IsKbdCmd(cur):
    while True:
        if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:
            key = sys.stdin.read(1)
            if key == 'x':
                return False
            elif key == ' ':
                state['pause'] = not state['pause']
                if state['pause']:
                    print "\n--- press space to resume ---"
            elif key == 's':
                cur.execute('select count(*) from trxs')
                print "\nTx: {:,}".format(cur.fetchone()[0])
                cur.execute('select count(*) from outputs')
                outs = cur.fetchone()[0]
                cur.execute('select count(*) from outputs where sig != 0')
                spent = cur.fetchone()[0]
                print "TxO: {:,}\nUTxO: {:,} - {:.0%}".format(outs, outs-spent, float(outs-spent)/outs)
                cur.execute('select count(*) from address')
                print "Addr: {:,}".format(cur.fetchone()[0])
                #print "Size: %4.1f MB" % (os.path.getsize('btc.db')/1e6)
                print
            elif key == 'b':
                import shutil
                print "\n--- backing up db ---"
                shutil.copy2('btc.db', 'btc.db.bak')
            
        if not state['pause']:
            return True
        time.sleep(0.5)

def getBlocks(blk):
    rpc = AuthServiceProxy(cfg['rpc'])
    blkChkPoint = rpc.getblockcount() # prevent wasteful rpc calls when known redundant
    sql = db.connect(*cfg['db'].split(':'))
    cur = sql.cursor()
    if blk == 0:
        cur.execute('select ifnull(max(id), -1) from blocks')
        blk = int(cur.fetchone()[0] + 1)
    startblk = blk
    while IsKbdCmd(cur):
        if len(blockQ) >= 8:
            time.sleep(0.01)
            continue
        if blk > blkChkPoint and blk > rpc.getblockcount():
            waitfrom = time.time()
            checkMemPool(cur, rpc)
            time.sleep(10 - (time.time() - waitfrom))
            continue
        netstart = time.time()
        blkhash = rpc.getblockhash(blk)
        if blkhash:
            data = decodeBlock(rpc.getblock(blkhash, False).decode('hex'))
            if data: 
                data['height'] = blk
                data['rpc'] = time.time()-netstart
                blockQ.append(data)
                blk += 1
            else: break
    return blk - startblk
        
def processBlocks():
    sql = db.connect(*cfg['db'].split(':'))
    cur = sql.cursor()
    while not done.isSet():
        if len(blockQ) > 0:
            print len(blockQ),
            insertBlock(cur, blockQ.pop(0))
        else:
            time.sleep(0.01)

def checkMemPool(cur, rpc):
    if len(memPool) == 0:
        sync_id = 0
        cur.execute("delete from mempool;")
    else:
        cur.execute("select max(sync_id) from mempool;")
        sync_id = cur.fetchone()[0]
    trxs = rpc.getrawmempool()
    for tx in trxs:
        if tx not in memPool:
            memPool.add(tx)
            insertTxMemPool(rpc.getrawtransaction(tx,1), sync_id+1)           

def decodeBlock(data):
    hdr = ['version','previousblockhash','merkleroot', 'time', 'bits', 'nonce']
    hv = unpack_from('<I32s32s3I', data)
    block = dict(zip(hdr,hv))
    block['hdr'] = data[:80]
    block['hash'] = sha256(sha256(block['hdr']).digest()).digest()
    block['bits'] = '%08x' % block['bits'] 
    txcnt,off = decodeVarInt(data[80:89])
    off += 80
    block['tx'] = []
    while txcnt > 0:
        tx = decodeTx(data[off:])
        block['tx'].append(tx)
        off += tx['size']
        txcnt -= 1
    block['height'] = 0
    block['coinbase'] = block['tx'][0]['vin'][0]['coinbase']
    if block['version'] > 1 and block['height'] >= 227836 and block['coinbase'][0] == '\x03':
        block['height'] = unpack('<I', block['coinbase'][1:4]+'\0')[0]
        #print 'coinbase height', block['height'], block['tx'][0]['vin'][0]['coinbase'][1:4].encode('hex')
    return block

def decodeTx(data):
    vers, = unpack_from('<I', data)
    tx = { 'version': vers, 'vin':[], 'vout':[] }
    vicnt,off = decodeVarInt(data[4:13])
    off += 4
    while vicnt > 0:
        txid,vout = unpack_from('<32sI', data, off)
        sigsz,soff = decodeVarInt(data[off+36:off+36+9])
        off += soff+36
        seq, = unpack_from('<I', data, off+sigsz)
        if txid == '\0'*32 and vout == 0xffffffff: 
            tx['vin'].append({'coinbase':data[off:off+sigsz], 'sequence':seq })
        else:
            tx['vin'].append({'txid':txid, 'vout':vout, 'scriptSig':data[off:off+sigsz], 'sequence':seq })
        off += sigsz+4
        vicnt -= 1
    vocnt,voff = decodeVarInt(data[off:off+9])
    off += voff
    n = 0
    while n < vocnt:
        value, = unpack_from('<Q', data, off)
        pksz,soff = decodeVarInt(data[off+8:off+8+9])
        off += 8+soff
        tx['vout'].append({'value':value, 'n':n, 'scriptPubKey':decodeScriptPK( data[off:off+pksz] ) }) 
        off += pksz
        n += 1
    tx['locktime'], = unpack_from('<I', data, off)
    tx['size'] = off+4
    tx['txid'] = sha256(sha256(data[:tx['size']]).digest()).digest()
    return tx
       
def insertTxMemPool(tx, sync_id):
    tx_id = findTx(cur, tx['txid'], mkNew=True)
    if tx_id == None:
        ins,outs = InsertTx(cur, tx, tx_id, 0)
        cur.executemany("insert ignore into outputs (id,addr_id,value) values(%s,%s,%s)", outs)
        cur.executemany("update outputs set tx_id=%s where id=%s limit 1", ins)
    cur.execute("insert ignore into mempool (id,sync_id) values(%s,%s);", (tx_id, sync_id))

def insertTx(cur, tx, tx_id, blk_id):
    inlist,outlist = [],[]
    in_ids,txdata = '','' 
    stdSeq = True
    for vin in tx['vin']:
        if vin['sequence'] != 0xffffffff:
            stdSeq = False
            break
    for vin in tx['vin']:
        if 'coinbase' not in vin:
            in_id = findTx(cur, vin['txid'])
            if in_id and vin['vout'] < MAX_IO_TX:
                in_id = (in_id*MAX_IO_TX) + vin['vout']
                inlist.append(( tx_id, in_id ))
                in_ids += pack('<Q', in_id)[:7]
                txdata += encodeVarInt(len(vin['scriptSig'])) + vin['scriptSig']
                if not stdSeq:
                    txdata += pack('<I', vin['sequence'])
                                       
    for vout in tx['vout']:
        addr_id = insertAddress(cur, vout['scriptPubKey']['addr']) if 'addr' in vout['scriptPubKey'] else 0
        if vout['n'] < MAX_IO_TX:
            outlist.append(( tx_id*MAX_IO_TX + vout['n'], addr_id, vout['value'] ))
            txdata += encodeVarInt(len(vout['scriptPubKey']['data'])) + vout['scriptPubKey']['data']
            
    ins,outs,sz,txhdr = mkBlobHdr(len(inlist), len(outlist), tx, stdSeq)
    cur.execute("insert ignore into trxs (id,hash,ins,outs,txsize,txdata,block_id) values(%s,%s,%s,%s,%s,%s,%s)", 
        ( tx_id, tx['txid'], ins, outs, sz, insertBlob(txhdr + in_ids + txdata), blk_id ))    
    return inlist,outlist
            
def insertBlock(cur, data):
    print "block", data['height'], 
    blkstart = time.time()
    blk_id = data['height']*MAX_TX_BLK
    ins,outs = [],[]
    for n,tx in enumerate(data['tx']):
        tx_id = findTx(cur, tx['txid'], mkNew=True)
        if tx_id in memPool:
            memPool.remove(tx['txid'])
            cur.execute("delete from mempool where id=%s limit 1;", (tx_id,))
        xi,xo = insertTx(cur, tx, tx_id, blk_id + n)
        ins.extend(xi)
        outs.extend(xo)
    cur.executemany("insert ignore into outputs (id,addr_id,value) values(%s,%s,%s)", outs)
    cur.executemany("update outputs set tx_id=%s where id=%s limit 1", ins)
    cur.execute("insert ignore into blocks (id,hash,coinbase) values (%s,%s,%s);", (data['height'], data['hash'], data['coinbase']))
    puthdr(data['height'], data['hdr'])
    blktime = time.time() - blkstart
    print "[ %4d txs - %s - %3.0fms %2.1fs %3.0f tx/s]" % ( len(data['tx']), datetime.fromtimestamp(data['time']).strftime('%d-%m-%Y'), data['rpc']*1000, blktime, len(data['tx'])/blktime)

    
if __name__ == '__main__':

    loadcfg(cfg)
    
    blk = 0
    if len(sys.argv) > 1:
        blk = int(sys.argv[1])

    # set console for non-blocking key input
    fd = sys.stdin.fileno()
    oldterm = termios.tcgetattr(fd)
    newattr = termios.tcgetattr(fd)
    newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO
    termios.tcsetattr(fd, termios.TCSANOW, newattr)
    
    oldflags = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, oldflags | os.O_NONBLOCK)
    
    workstart = time.time()
    blkwrk = threading.Thread(target = processBlocks)
    blkwrk.start()
    
    blks = None
    while True:
        try:
            blks = getBlocks(blk)
            break
        except socket.error:
            print "Cannot connect to rpc"
            time.sleep(5)
            pass
        except KeyboardInterrupt:
            done.set()
            break
        #except:
            #print "Unknown error"
            #time.sleep(5)
            #pass
    
    # let block processing finish
    done.set()
    blkwrk.join()
    if blks:
        print "Session %.2f blks/s" % float(blks / (time.time() - workstart))
    
    # restore console
    termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm)
    fcntl.fcntl(fd, fcntl.F_SETFL, oldflags)

    


    

