#!/usr/bin/env python
#
# Test bitcoin-rpc

import os, sys, socket, datetime, time
import select, termios, fcntl
import sqlite3 as db
from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException
from decimal import *
from struct import unpack
import json

state = { 'pause':False }

# encode json btc values as satoshis
class btcEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, Decimal):
            return int(o*Decimal(1e8))
        return super(btcEncoder, self).default(o)

alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

def b58bin(v):
    long_value = 0L
    for (i, c) in enumerate(v[::-1]):
        long_value += alphabet.find(c) * (58**i)
    result = ''
    while long_value >= 256:
        div, mod = divmod(long_value, 256)
        result = chr(mod) + result
        long_value = div
    result = chr(long_value) + result
    nPad = 0
    for c in v:
        if c == alphabet[0]: nPad += 1
        else: break
    result = chr(0)*nPad + result
    return buffer(result[1:-4])

def mkaddr(v):
    pad = ''
    an = chr(0) + str(v)
    for c in an:
        if c == '\0': pad += '1'
        else: break
    num = long((an + hashlib.sha256(hashlib.sha256(an).digest()).digest()[0:4]).encode('hex'), 16)
    out = ''
    while num >= 58:
        num,m = divmod(num, 58)
        out = alphabet[m] + out
    return pad + alphabet[num] + out    
   
def IsKbdCmd(cur):
    while True:
        if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:
            key = sys.stdin.read(1)
            if key == 'x':
                return False
            elif key == ' ':
                state['pause'] = not state['pause']
                if state['pause']:
                    print "\n--- press space to resume ---"
            elif key == 's':
                cur.execute('select count() from trxs')
                print "\nTx: {:,}".format(cur.fetchone()[0])
                cur.execute('select count() from outputs')
                outs = cur.fetchone()[0]
                cur.execute('select count() from scripts where length(script_in) > 0')
                spent = cur.fetchone()[0]
                print "TxO: {:,}\nuTxO: {:,} - {:.0%}".format(outs, outs-spent, float(outs-spent)/outs)
                cur.execute('select count() from address')
                print "Addr: {:,}".format(cur.fetchone()[0])
                print "Size: %4.1f MB" % (os.path.getsize('bitcoin.db')/1e6)
                print
            elif key == 'b':
                import shutil
                print "\n--- backing up db ---"
                shutil.copy2('bitcoin.db', 'bitcoin.db.bak')
            
        if not state['pause']:
            return True
        time.sleep(0.5)

def main():
    rpc = AuthServiceProxy("http://bogustester:cZ9k7ca22UIwPobTGQUm@127.0.0.1:8332")
    sql = db.connect('bitcoin.db')
    cur = sql.cursor()
    cur.execute("PRAGMA synchronous = OFF")
    cur.execute("PRAGMA journal_mode = OFF")
    cur.execute('select ifnull(max(id)/8, -1) from blocks')
    blk = cur.fetchone()[0] + 1
    while IsKbdCmd(cur):
        blkhash = rpc.getblockhash(blk)
        if blkhash:
            data = rpc.getblock(blkhash)
            if data:
                try:
                    insertBlock(cur, rpc, data)
                    sql.commit()
                except db.Error as err:
                    print err
                    sql.rollback()
            blk += 1

def insertAddress(cur, addr):
    addr_id, = unpack('<q', addr[:5]+'\0'*3) 
    cur.execute("select addr from address where id=?", (addr_id,))
    row = cur.fetchone()
    if row == None or row[0] != addr:
        while True:
            try: 
                cur.execute("insert into address (id,addr) values(?,?)", (addr_id, addr))
            except db.IntegrityError:
                print '!',
                addr_id += 1
            else: break
    return addr_id
    
def insertTx(cur, blk_id, txhash, inputs):
    tx_id, = unpack('<q', txhash[:5]+'\0'*3)
    tx_id /= 16
    while True:
        try: 
            cur.execute("insert into trxs (id,hash,inputs,block_id) values(?,?,?,?)", (tx_id, txhash, inputs, blk_id))
        except db.IntegrityError:
            print '#',
            tx_id += 1
        else: break
    return tx_id
    
def findTx(cur, txhash):
    tx_id, = unpack('<q', txhash[:5]+'\0'*3) 
    tx_id /= 16
    while True:
        cur.execute("select hash from trxs where id=?", (tx_id,))
        row = cur.fetchone()
        if row and row[0] == txhash:
            return tx_id
        tx_id += 1

def insertBlock(cur, rpc, data):
    print "block", data['height'],
    blkstart = time.time()
    blk_id = data['height']*8
    hdr = ('%08x%s%s%s%08x%08x' % (int(data['version']),data.get('previousblockhash', '0'*64),data['merkleroot'],data['bits'],data['time'],data['nonce'])).decode('hex')
    cur.execute("insert into blocks (id,hash,hdr) values (?,?,?);", (blk_id, db.Binary(data['hash'].decode('hex')), hdr))
    txcount = 0
    qcnt = 1
    for txhash in data['tx']:
        try:
            txdata = rpc.getrawtransaction(txhash, 1)
        except JSONRPCException as e:
            print "Err", e.args
            continue
        inputs = ''
        for vin in txdata['vin']:
            if 'coinbase' in vin:
                cur.execute("update blocks set coinbase=? where id=?", (db.Binary(vin['coinbase'].decode('hex')), blk_id))
                qcnt += 1
            if 'txid' in vin:
                tx_id = findTx(cur, db.Binary(vin['txid'].decode('hex')))
                in_id = tx_id*4096 + vin['vout']
                inputs += '%012x' % in_id
                script_in = vin['scriptSig']['hex'] + '%08x' % vin['sequence']
                cur.execute("update scripts set script_in=? where out_id=?", (db.Binary(script_in.decode('hex')), in_id))
                qcnt += 2
        tx_id = insertTx(cur, blk_id, db.Binary(txhash.decode('hex')), db.Binary(inputs.decode('hex')))
        txcount += 1
        qcnt += 1
        outputs = ''
        for vout in txdata['vout']:
            if 'addresses' in vout['scriptPubKey']:
                out_id = tx_id*4096 + vout['n']
                addr_id = insertAddress(cur, b58bin(vout['scriptPubKey']['addresses'][0]))
                cur.execute("insert into outputs (id,addr_id,value) values(?,?,?)", (out_id, addr_id, int(vout['value']*Decimal(1e8))))
                script_out = vout['scriptPubKey']['hex']
                if vout['n']+1 == len(txdata['vout']):
                    script_out += '%08x%08x' % (txdata['version'], txdata['locktime'])
                cur.execute("insert into scripts (out_id,script_out) values (?,?)", (out_id, db.Binary(script_out.decode('hex'))))
                outputs += '%012x' % out_id
                qcnt += 3      
        if len(outputs) > 0:
            cur.execute("update trxs set outputs=? where id=?;", (db.Binary(outputs.decode('hex')), tx_id))
            qcnt += 1
    blktime = time.time() - blkstart
    print "[ %3d txs - %s - %4d q/s ]" % (txcount, datetime.datetime.fromtimestamp(data['time']).strftime('%d-%m-%Y'), int(qcnt/blktime))

    
if __name__ == '__main__':

    # set console for non-blocking key input
    fd = sys.stdin.fileno()
    oldterm = termios.tcgetattr(fd)
    newattr = termios.tcgetattr(fd)
    newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO
    termios.tcsetattr(fd, termios.TCSANOW, newattr)
    
    oldflags = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, oldflags | os.O_NONBLOCK)

    try:
        main()
    except socket.error:
        print "Cannot connect to rpc"
    except KeyboardInterrupt:
        pass
    finally:
        # restore console
        termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm)
        fcntl.fcntl(fd, fcntl.F_SETFL, oldflags)
    


    

