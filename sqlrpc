#!/usr/bin/env python
#
# sqlcoin - build sql blockchain db
#

import os, sys, socket, datetime, time
import select, termios, fcntl
from bitcoinrpc.authproxy import AuthServiceProxy
from decimal import *
from struct import pack, unpack, unpack_from
import json, hashlib
import sqlite3 as db

state = { 'pause':False }

# encode json btc values as satoshis
class btcEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, Decimal):
            return int(o*Decimal(1e8))
        return super(btcEncoder, self).default(o)

alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

def mkpkh(pk):
    rmd = hashlib.new('ripemd160')
    rmd.update(hashlib.sha256(pk).digest())
    return rmd.digest()

def addr2pkh(v):
    long_value = 0L
    for (i, c) in enumerate(v[::-1]):
        long_value += alphabet.find(c) * (58**i)
    result = ''
    while long_value >= 256:
        div, mod = divmod(long_value, 256)
        result = chr(mod) + result
        long_value = div
    result = chr(long_value) + result
    nPad = 0
    for c in v:
        if c == alphabet[0]: nPad += 1
        else: break
    result = chr(0)*nPad + result
    return buffer(result[1:-4])

def mkaddr(pkh):
    pad = ''
    an = chr(0) + str(pkh)
    for c in an:
        if c == '\0': pad += '1'
        else: break
    num = long((an + hashlib.sha256(hashlib.sha256(an).digest()).digest()[0:4]).encode('hex'), 16)
    out = ''
    while num >= 58:
        num,m = divmod(num, 58)
        out = alphabet[m] + out
    return pad + alphabet[num] + out    
   
def IsKbdCmd(cur):
    while True:
        if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:
            key = sys.stdin.read(1)
            if key == 'x':
                return False
            elif key == ' ':
                state['pause'] = not state['pause']
                if state['pause']:
                    print "\n--- press space to resume ---"
            elif key == 's':
                cur.execute('select count() from trxs')
                print "\nTx: {:,}".format(cur.fetchone()[0])
                cur.execute('select count() from outputs')
                outs = cur.fetchone()[0]
                cur.execute('select count() from scripts where length(sig) > 0')
                spent = cur.fetchone()[0]
                print "TxO: {:,}\nuTxO: {:,} - {:.0%}".format(outs, outs-spent, float(outs-spent)/outs)
                cur.execute('select count() from address')
                print "Addr: {:,}".format(cur.fetchone()[0])
                print "Size: %4.1f MB" % (os.path.getsize('bitcoin.db')/1e6)
                print
            elif key == 'b':
                import shutil
                print "\n--- backing up db ---"
                shutil.copy2('bitcoin.db', 'bitcoin.db.bak')
            
        if not state['pause']:
            return True
        time.sleep(0.5)

def main():
    rpc = AuthServiceProxy("http://chris:cZ9k7ca22UIwPobTGQUm@sneezy:8332")
    sql = db.connect('bitcoin.db')
    cur = sql.cursor()
    cur.execute("PRAGMA synchronous = OFF")
    cur.execute("PRAGMA journal_mode = OFF")
    cur.execute('select ifnull(max(id)/4, -1) from blocks')
    blk = cur.fetchone()[0] + 1
    while IsKbdCmd(cur):
        blkhash = rpc.getblockhash(blk)
        if blkhash:
            data = decodeBlock(rpc.getblock(blkhash, False).decode('hex'))
            if data and verifyBlock(cur, data):
                try:
                    insertBlock(cur, data)
                    sql.commit()
                except db.Error as err:
                    print err
                    sql.rollback()
                blk += 1
            else: 
                return

def decodeBlock(data):
    hdr = ['version','previousblockhash','merkleroot', 'time', 'bits', 'nonce']
    hv = unpack_from('<I32s32s3I', data)
    block = dict(zip(hdr,hv))
    block['hdr'] = data[:80]
    block['hash'] = hashlib.sha256(hashlib.sha256(block['hdr']).digest()).digest()
    block['bits'] = '%08x' % block['bits'] 
    txcnt,off = decodeVarInt(data[80:89])
    off += 80
    block['tx'] = []
    while txcnt > 0:
        tx,toff = decodeTx(data[off:])
        block['tx'].append(tx)
        off += toff
        txcnt -= 1
    block['height'] = 0
    if block['version'] > 1:
        block['height'] = unpack('<I', block['tx'][0]['vin'][0]['coinbase'][1:4]+'\0')[0]
    return block

def verifyBlock(cur, data):
    cur.execute("select id from blocks where hash=?", (db.Binary(data['previousblockhash']),))
    row = cur.fetchone()
    if row:
        height = row[0] / 4 + 1
        if data['height'] != 0 and data['height'] != height:
            print "block height mismatch - coinbase height bad"
            return False
        data['height'] = height
    elif data['height'] != 0:
        print "orphan block - previous hash not found"
    
    mkt = [ tx['txid'] for tx in data['tx'] ]
    while len(mkt) > 1:
        if len(mkt) % 2 == 1:
            mkt.append(mkt[-1])
        mkt = [ hashlib.sha256(hashlib.sha256(mkt[i]+mkt[i+1]).digest()).digest() for i in range(0,len(mkt),2) ]
    if mkt[0] != data['merkleroot']:
        print "merkle tree failure"
    
    totalfees = ( int(50e8) >> ( data['height']/210000 ) )
    for tx in data['tx']:
        valid,fee = verifyTx(cur, data, tx)
        if not valid:
            return False
        totalfees += fee
    if totalfees != 0:
        print "coinbase payout off by", totalfees
        return False
    # todo,check time and bits
    return True
    
def decodeTx(data):
    vers, = unpack_from('<I', data)
    tx = { 'version': vers, 'vin':[], 'vout':[] }
    vicnt,off = decodeVarInt(data[4:13])
    off += 4
    while vicnt > 0:
        txid,vout = unpack_from('<32sI', data, off)
        sigsz,soff = decodeVarInt(data[off+36:off+36+9])
        off += soff+36
        seq, = unpack_from('<I', data, off+sigsz)
        if txid == '\0'*32 and vout == 0xffffffff: 
            tx['vin'].append({'coinbase':data[off:off+sigsz], 'sequence':seq })
        else:
            tx['vin'].append({'txid':txid, 'vout':vout, 'scriptSig':data[off:off+sigsz], 'sequence':seq })
        off += sigsz+4
        vicnt -= 1
    vocnt,voff = decodeVarInt(data[off:off+9])
    off += voff
    n = 0
    while n < vocnt:
        value, = unpack_from('<Q', data, off)
        pksz,soff = decodeVarInt(data[off+8:off+8+9])
        off += 8+soff
        tx['vout'].append({'value':value, 'n':n, 'scriptPubKey':decodeScriptPK( data[off:off+pksz] ) }) 
        off += pksz
        n += 1
    tx['locktime'], = unpack_from('<I', data, off)
    tx['txid'] = hashlib.sha256(hashlib.sha256(data[:off+4]).digest()).digest()
    return tx,off+4
    
def verifyTx(cur, block, tx):
    fee = 0
    for vin in tx['vin']:
        if 'txid' in vin:
            n = vin['vout']
            vout = TxInBlock(block, tx['txid'], vin['txid']) # may be in same block
            if vout and 'addr' in vout[n]['scriptPubKey']:
                if not verifyInput(vin['scriptSig'], vout[n]['scriptPubKey']['data'], vout[n]['scriptPubKey']['addr']):
                    print "bad input"
                    return False
                fee += vout[n]['value']
            else:
                tx_id = findTx(cur, vin['txid']) # otherwise has to be in prev block
                if tx_id == None:
                    print "tx invalid - no tx for this input", vin['txid'][::-1].encode('hex'), tx['txid'][::-1].encode('hex')
                    return False,0
                cur.execute("select value,addr,pk from outputs o,address a,scripts s where o.id=? and a.id=o.addr_id and s.out_id=o.id", (tx_id*4096 + n, ))
                row = cur.fetchone()
                if row == None:
                    print "tx invalid - no output for this input", tx_id*4096 + n
                    return False,0
                value,pkh,pk = row
                if not verifyInput(vin['scriptSig'], pk, pkh):
                    print "bad input"
                    return False
                fee += value
            
    for vout in tx['vout']:
        fee -= vout['value']
        
    return True,fee

def TxInBlock(block, brkid, txid):
    for tx in block['tx']:
        if tx['txid'] == brkid:
            return None
        if tx['txid'] == txid:
            return tx['vout']
        
def verifyInput(sig, pk, pkh):
    #print 'verify s=%s, pk=%s, pkh=%s' % (str(sig).encode('hex'), str(pk).encode('hex'), str(pkh).encode('hex'))
    return True

def decodeScriptPK(data):
    if data[:3] == '\x76\xa9\x14' and data[23:25] == '\x88\xac': # P2PKH
        return { 'type':'p2pkh', 'data':'', 'addr':mkaddr(data[3:23]) };
    if data[0] == '\xa9' and data[21] == '\x87': # P2SH
        return { 'type':'p2sh', 'data':'', 'addr':data[1:21] };
    if data[0] == '\x41' and data[66] == '\xac': # P2PK
        return { 'type':'p2pk', 'data':data, 'addr':mkaddr(mkpkh(data[1:66])) };
    if len(data) <= 41 and data[0] == '\x6a': # NULL
        return { 'type':'null', 'data':data };
    return { 'type':'other', 'data':data } # other, non-std

def decodeVarInt(v):
    if v[0] <= '\xfc':
        return unpack('<B', v[0])[0],1
    if v[0] == '\xfd':
        return unpack('<H', v[1:3])[0],3
    if v[0] == '\xfe':
        return unpack('<I', v[1:5])[0],5
    return unpack('<Q', v[1:9])[0],9
    
def insertAddress(cur, addr):
    pkh = addr2pkh(addr)
    addr_id, = unpack('<q', pkh[:5]+'\0'*3) 
    addr_id *= 2
    if addr[0] == '3': # encode P2SH as odd id, P2PKH as even id
        addr_id += 1
    cur.execute("select addr from address where id=?", (addr_id,))
    row = cur.fetchone()
    if row == None or str(row[0]) != str(pkh):
        while True:
            try: 
                cur.execute("insert into address (id,addr) values(?,?)", (addr_id, pkh))
            except db.IntegrityError:
                print '!',
                addr_id += 2
            else: break
    return addr_id
    
def insertTx(cur, blk_id, txhash, inputs, extra): # extra is prunable: vers, locktime
    tx_id, = unpack('<q', txhash[:5]+'\0'*3)
    tx_id /= 16
    while True:
        try: 
            cur.execute("insert into trxs (id,hash,inputs,block_id) values(?,?,?,?)", (tx_id, db.Binary(txhash+extra), inputs, blk_id))
        except db.IntegrityError:
            print '#',
            tx_id += 1
        else: break
    return tx_id
    
def findTx(cur, txhash, limit=256):
    tx_id, = unpack('<q', txhash[:5]+'\0'*3) 
    tx_id /= 16
    limit_id = tx_id+limit
    while True:
        cur.execute("select hash from trxs where id=?", (tx_id,))
        row = cur.fetchone()
        if row and str(row[0][:32]) == str(txhash):
            return tx_id
        if tx_id > limit_id:
            #print "tx miss", str(txhash[::-1]).encode('hex')
            return None
        tx_id += 1

def insertBlock(cur, data):
    print "block", data['height'],
    blkstart = time.time()
    blk_id = data['height']*4
    cur.execute("insert into blocks (id,hash,hdr) values (?,?,?);", (blk_id, db.Binary(data['hash']), db.Binary(data['hdr'])))
    qcnt = 1
    for tx in data['tx']:
        inputs = ''
        for vin in tx['vin']:
            if 'coinbase' in vin:
                cur.execute("update blocks set coinbase=? where id=?", (db.Binary(vin['coinbase']), blk_id))
                qcnt += 1
            if 'txid' in vin:
                tx_id = findTx(cur, db.Binary(vin['txid']))
                in_id = tx_id*4096 + vin['vout']
                inputs += '%012x' % in_id
                sig = vin['scriptSig'] + ('%08x' % vin['sequence']).decode('hex')
                cur.execute("update scripts set sig=? where out_id=?", (db.Binary(sig), in_id))
                qcnt += 2
        tx_id = insertTx(cur, blk_id, tx['txid'], db.Binary(inputs.decode('hex')), pack('<BI', tx['version'], tx['locktime']))
        qcnt += 1
        outputs = ''
        for vout in tx['vout']:
            out_id = tx_id*4096 + vout['n']
            addr_id = insertAddress(cur, vout['scriptPubKey']['addr']) if 'addr' in vout['scriptPubKey'] else 0
            cur.execute("insert into outputs (id,addr_id,value) values(?,?,?)", (out_id, addr_id, vout['value']))
            pk = vout['scriptPubKey']['data']
            cur.execute("insert into scripts (out_id,pk) values (?,?)", (out_id, db.Binary(pk)))
            outputs += '%012x' % out_id
            qcnt += 3      
        if len(outputs) > 0:
            cur.execute("update trxs set outputs=? where id=?;", (db.Binary(outputs.decode('hex')), tx_id))
            qcnt += 1
    blktime = time.time() - blkstart
    print "[ %3d txs - %s - %4d q/s ]" % (len(data['tx']), datetime.datetime.fromtimestamp(data['time']).strftime('%d-%m-%Y'), int(qcnt/blktime))

    
if __name__ == '__main__':

    # set console for non-blocking key input
    fd = sys.stdin.fileno()
    oldterm = termios.tcgetattr(fd)
    newattr = termios.tcgetattr(fd)
    newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO
    termios.tcsetattr(fd, termios.TCSANOW, newattr)
    
    oldflags = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, oldflags | os.O_NONBLOCK)

    try:
        main()
    except socket.error:
        print "Cannot connect to rpc"
    except KeyboardInterrupt:
        pass
    finally:
        # restore console
        termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm)
        fcntl.fcntl(fd, fcntl.F_SETFL, oldflags)
    


    

