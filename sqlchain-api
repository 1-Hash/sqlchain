#!/usr/bin/env python

import os, sys, pwd, getopt, time, cgi, urlparse, signal, daemon
import threading, mimetypes, json, gevent

from geventwebsocket import WebSocketServer, WebSocketApplication, Resource
from collections import OrderedDict
from datetime import datetime
from time import sleep
from string import hexdigits
from hashlib import sha256
from struct import pack, unpack, unpack_from

from lib.dbpool import *
from lib.sqlchain import *

__builtins__.sqc = dotdict()  # container for super globals 

sqc.cfg = { 'log':sys.argv[0]+'.log', 'listen':'localhost:8085', 'www':'www', 'db':'localhost:btc:test623btc:bitcoin', 'block':0,
            'rpc':'http://chris:cZ9k7ca22UIwPobTGQUm@cubian:8332', 'pool':4, 'lastDBts':datetime.now() }
sqc.srvinfo = { 'info':{ 'version':"0.1.0" }, 'db':{'all':{}} }

sqc.sync = threading.Condition();
sqc.sync_id = 0

def do_Root(env, send_resp):
    try:
        path = env['PATH_INFO']
        if env['REQUEST_METHOD'] == 'POST': # POST
            if path == '/': # the /rpc api is mirrored on / 
                form = cgi.FieldStorage(fp=env['wsgi.input'], environ=env, keep_blank_values=True)
                env['PATH_INFO'] = "/rpc/%s/%s" % (form['method'].value, "/".join(form.getlist('params')))
                return lib.rpc.do_RPC(env, send_resp)
        else: # GET static website files
            path = '/main.html' if path in ['', '/'] else path
            if os.path.isfile(sqc.cfg['www']+path):
                _,ext = os.path.splitext(path)
                filesize = os.path.getsize(sqc.cfg['www']+path)
                with open(sqc.cfg['www']+path) as fd:
                    send_resp('200 OK', [('Content-Type', mimetypes.types_map[ext]), ('Content-Length', filesize), 
                                         ('Expires', datetime.utcfromtimestamp(time.time()+3600).strftime("%a, %d %b %Y %H:%M:%S %ZGMT"))])
                    return [ fd.read() ]
        send_resp('404 - File Not Found: %s' % path, [("Content-Type", "text/html")], sys.exc_info())
        with open(sqc.cfg['www']+'/404.html') as fd:
            return [ fd.read() ]
    except IOError:
        pass

clients = {}
sqc.syncTxs,lastBlk = [],{}

class BCIWebSocket(WebSocketApplication):
    global clients
    remote = None
    def on_open(self):
        self.remote = self.ws.environ['REMOTE_ADDR']
        logts("WS Client connected from %s" % self.remote)
        clients[self.ws.handler.active_client] = { 'subs':[], 'addrs':[] }
        
    def on_message(self, msg):
        if msg:
            msg = json.loads(msg)
            if msg['op'] in [ 'blocks_sub', 'unconfirmed_sub' ]:
                clients[self.ws.handler.active_client]['subs'].append(msg['op'])
                if msg['op'] == 'addr_sub' and 'addr' in msg:
                    clients[self.ws.handler.active_client]['addrs'].append(msg['addr'])
            if msg['op'] == 'ping_block':
                self.ws.send({ 'op': 'block', 'x': lastBlk })
            if msg['op'] == 'ping_tx':
                if 'lasttx' in clients[self.ws.handler.active_client]:
                    self.ws.send(json.dumps({ 'op': 'utx', 'x': clients[self.ws.handler.active_client]['lasttx'] }))

    def on_close(self, reason):
        logts("WS Client disconnected %s %s" % (self.remote, reason))

# monitor for mempool, block, orphan changes and notify waiting sync connections or websocket subscriptions
def syncMonitor():
    with sqc.dbpool.get().cursor() as cur:
        cur.execute("select greatest(ifnull(m,0),ifnull(o,0)) from (select max(sync_id) as m from mempool) m,(select max(sync_id) as o from orphans) o;")
        sqc.sync_id = cur.fetchone()[0]
        cur.execute("select max(id) from blocks;")
        sqc.cfg['block'] = cur.fetchone()[0]
    while True:
        with sqc.dbpool.get().cursor() as cur:
            cur.execute("select hash from mempool m, trxs t where m.sync_id > %s and t.id=m.id;", (sqc.sync_id,))
            sqc.syncTxs = [] #todo build list data from cur.fetchall()
            cur.execute("select count(*) from orphans where sync_id > %s;", (sqc.sync_id,))
            new_orphans = cur.fetchone()[0] > 0
            cur.execute("select max(id) from blocks;")
            block = cur.fetchone()[0]
        if block != sqc.cfg['block'] or new_orphans or len(sqc.syncTxs) > 0:
            if not ('hash' in lastBlk): # testing, disable continuous
                do_Sync(block)
        if (datetime.now() - sqc.cfg['lastDBts']).total_seconds() > 3*60*60:
            with sqc.dbpool.get().cursor() as cur:
                mkDBInfo(cur)
        sleep(5) 
            
def do_Sync(block):
    global lastBlk
    if block != sqc.cfg['block']:
        sqc.cfg['block'] = min(block, sqc.cfg['block']+1)
        with sqc.dbpool.get().cursor() as cur:
            lastBlk = lib.bci.bciBlockWS(cur, block)
        for client in server.clients.values():
            if 'blocks_sub' in clients[client]['subs']:
                client.ws.send(json.dumps({ 'op': 'block', 'x': lastBlk })) 
    sqc.sync_id += 1
    with sqc.sync:
        sqc.sync.notifyAll()
    if len(sqc.syncTxs) > 0:
        for client in server.clients.values():
            for tx in sqc.syncTxs:
                if 'unconfirmed_sub' in clients[client]['subs']:
                    client.ws.send(json.dumps({ 'op': 'utx', 'x': tx }))
                    clients[client]['lasttx'] = tx
                if len(clients[client]['addrs']) > 0:
                    pass # todo check tx address against list and send tx  

def mkDBInfo(cur):
    logts("Updating server db info")
    lib.insight.apiStatus(cur, 'db')
    cur.execute("select count(*) from address where id%2=1;")
    sqc.srvinfo['db']['address']['multi-sigs'] = cur.fetchone()[0]
    cur.execute("select count(*) from address where  cast(conv(hex(reverse(unhex(substr(sha2(addr,0),1,10)))),16,10)*2 as unsigned) != id;")
    sqc.srvinfo['db']['address']['id-collisions'] = cur.fetchone()[0]
    cur.execute("select count(*) from trxs where  strcmp(reverse(unhex(hex(id*8))), left(hash,5)) > 0;")
    sqc.srvinfo['db']['trxs']['id-collisions'] = cur.fetchone()[0] 
    cur.execute("select count(*) from outputs where addr_id=0;")
    sqc.srvinfo['db']['outputs']['non-std'] = cur.fetchone()[0] 
    cur.execute("select count(*) from outputs where tx_id is null;")
    sqc.srvinfo['db']['outputs']['unspent'] = cur.fetchone()[0]
    sqc.srvinfo['.']['ts'] = datetime.now()
    sqc.srvinfo['db']['all']['updated'] = sqc.cfg['lastDBts'].strftime('%d-%m-%Y %H:%M:%S')


def options():
    try:                         
        opts,args = getopt.getopt(sys.argv[1:], "hvb:p:c:d:l:w:p:b:r:u:", 
            ["help", "version", "debug", "db=", "log=", "www=", "listen=", "rpc=", "user=", "defaults" ])
    except getopt.GetoptError:
        usage()
    for opt,arg in opts:
        if opt in ("-h", "--help"):
            usage()
        elif opt in ("-v", "--version"):
            sys.exit(sys.argv[0]+': '+sqc.srvinfo['info']['version'])
        elif opt in ("-d", "--db"):
            sqc.cfg['db'] = arg
        elif opt in ("-l", "--log"):
            sqc.cfg['log'] = arg
        elif opt in ("-w", "--www"):
            sqc.cfg['www'] = arg            
        elif opt in ("-p", "--listen"):
            sqc.cfg['listen'] = arg
        elif opt in ("-r", "--rpc"):
            sqc.cfg['rpc'] = arg
        elif opt in ("-u", "--user"):
            sqc.cfg['user'] = arg
        elif opt in ("--defaults"):
            savecfg(sqc.cfg)
            sys.exit("%s updated" % (sys.argv[0]+'.cfg'))
        elif opt in ("--debug"):
            sqc.cfg['debug'] = True
            
def usage():
    print """Usage: %s [options...][cfg file]\nCommand options are:\n-h,--help\tShow this help info\n-v,--version\tShow version info
--defaults\tUpdate cfg and exit\nDefault files are %s.cfg .log .db
\nThese options get saved in cfg file as default.
-p,--listen\tSet host:port for web server\n-w,--www\tWeb server root directory\n-u,--user\tSet user to run as
-d,--db  \tSet mysql db connection, "host:user:pwd:dbname"\n-l,--log\tSet log file path
-r,--rpc\tSet rpc connection, "http://user:pwd@host:port" """ % (sys.argv[0], sys.argv[0])
    sys.exit(2) 
    
def sigterm_handler(_signo, _stack_frame):
    logts("Shutting down.")
    if not sqc.cfg['debug']:
        os.unlink(sqc.cfg['pid'] if 'pid' in sqc.cfg else sys.argv[0]+'.pid')
    sys.exit(0)
    
def run():
    global server
    
    sqc.dbpool = DBPool(sqc.cfg['db'].split(':'), sqc.cfg['pool'], 'MySQLdb')

    mimetypes.init()
    mimetypes.add_type('application/x-font-woff', '.woff')
    mimetypes.add_type('application/x-font-woff2', '.woff2')
    mimetypes.add_type('application/x-font-woff', '.ttf')

    logts("Starting on %s" % sqc.cfg['listen'])
    host,port = sqc.cfg['listen'].split(':')
    cert = {'certfile':sqc.cfg['ssl']} if ('ssl' in sqc.cfg) and (sqc.cfg['ssl'] != '') else {}   
    server = WebSocketServer((host, int(port)), APIs, **cert)

    syncd = threading.Thread(target = syncMonitor)
    syncd.daemon = True
    syncd.start()
    
    drop2user(sqc.cfg)

    server.serve_forever()
    
if __name__ == '__main__':
    
    loadcfg(sqc.cfg)
    options()

    import lib.insight, lib.bci, lib.rpc
    
    APIs = Resource(OrderedDict(( 
        ('/api', lib.insight.do_API),
        ('/bci', lib.bci.do_BCI),
        ('/rpc', lib.rpc.do_RPC),
        ('/ws',  BCIWebSocket),
        ('/',    do_Root) ))) # order important

    if sqc.cfg['debug']:
        signal.signal(signal.SIGINT, sigterm_handler)
        run()
    else:
        with daemon.DaemonContext(working_directory='.', stdout=open(sys.argv[0]+'.log','a'), stderr=open(sys.argv[0]+'.log','a'), 
                signal_map={signal.SIGTERM:sigterm_handler } ):
            with file(sqc.cfg['pid'] if 'pid' in sqc.cfg else sys.argv[0]+'.pid','w') as f: 
                f.write(str(os.getpid()))
            run()

    
        
    
    


        
